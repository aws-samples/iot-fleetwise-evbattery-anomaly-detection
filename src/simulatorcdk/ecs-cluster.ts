import { readFileSync } from 'fs';
import * as path from 'path';
import { CfnParameter, Stack, Duration } from 'aws-cdk-lib';
import { CfnAutoScalingGroup, CfnLifecycleHook } from 'aws-cdk-lib/aws-autoscaling';
import {
  GenericLinuxImage,
  IMachineImage,
  LaunchTemplate,
  MachineImage, InstanceType, InstanceSize, InstanceClass,
  Peer,
  Port,
  SecurityGroup,
  UserData,
  Vpc,
} from 'aws-cdk-lib/aws-ec2';
import { CfnCapacityProvider, CfnCluster } from 'aws-cdk-lib/aws-ecs';
import { Rule } from 'aws-cdk-lib/aws-events';
import { LambdaFunction } from 'aws-cdk-lib/aws-events-targets';
import {
  Effect,
  ManagedPolicy,
  PolicyDocument,
  PolicyStatement,
  Role,
  ServicePrincipal,
} from 'aws-cdk-lib/aws-iam';
import { Code, Function, Runtime } from 'aws-cdk-lib/aws-lambda';
import { StringParameter } from 'aws-cdk-lib/aws-ssm';
import { CfnInclude } from 'aws-cdk-lib/cloudformation-include';
import { Construct } from 'constructs';
import { CreateEc2ImageUpdater } from './ec2-image-updater';

export interface VehicleSimulatorStackProps {
  ecsClusterStackId: string;
  ecsClusterStackName: string;
  ecsTaskStackId: string;
  ecsTaskStackName: string;
  ec2Cpu: string;
  ec2BaseImage: string;
  ecsClusterName: string;
  ecsCapacityProviderName: string;
  ecsClusterMinimumInstances: number;
  enableEc2AutoUpdate: boolean;
  ecsTaskDefinition: string;
  createS3Bucket: boolean;
}

export interface VehicleSimulatorEcsClusterStackProps {
  readonly stackName: string;
  readonly cpu: string;
  readonly ec2Key?: string;
  readonly ecsClusterName: string;
  readonly ecsCapacityProviderName: string;
  readonly ecsClusterMinimumInstances: number;
  readonly enableEc2AutoUpdate?: boolean;
  readonly baseImage: string;
}

export class VehicleSimulatorEcsClusterStack extends Stack {
  constructor(scope: Construct, id: string, props: VehicleSimulatorEcsClusterStackProps) {
    super(scope, id, {
      stackName: props.stackName,
    });

    // EC2 ASG Logical ID will be imported into User Data for signaling cloudformation resource
    const ec2AsgLogicalID = 'ec2asg';
    // If EC2 Auto Update enabled, the AMI generated by Image Pipeline will be stored at this parameter store
    const imageSsmParameterKey = `/ami/vehicle-simulator/${props.cpu}/latest`;
    /**
     * IAM Role for EC2 instances
     */
    const ec2Role = new Role(this, 'ec2-role', {
      assumedBy: new ServicePrincipal('ec2.amazonaws.com'),
      managedPolicies: [
        ManagedPolicy.fromAwsManagedPolicyName(
          'service-role/AmazonEC2ContainerServiceforEC2Role',
        ),
        ManagedPolicy.fromAwsManagedPolicyName(
          'AmazonEC2ContainerRegistryReadOnly',
        ),
        ManagedPolicy.fromAwsManagedPolicyName(
          'service-role/AmazonECSTaskExecutionRolePolicy',
        ),
        ManagedPolicy.fromAwsManagedPolicyName('AmazonSSMManagedInstanceCore'),
        ManagedPolicy.fromAwsManagedPolicyName(
          'service-role/AWSLambdaBasicExecutionRole',
        ),
      ],
    });

    ec2Role.assumeRolePolicy?.addStatements(
      new PolicyStatement({
        actions: ['sts:AssumeRole'],
        effect: Effect.ALLOW,
        principals: [new ServicePrincipal('ecs-tasks.amazonaws.com')],
      }),
    );

    ec2Role.assumeRolePolicy?.addStatements(
      new PolicyStatement({
        actions: ['sts:AssumeRole'],
        effect: Effect.ALLOW,
        principals: [new ServicePrincipal('lambda.amazonaws.com')],
      }),
    );
    /**
     * VPC
     */
    const vpc = new Vpc(this, 'ec2-vpc', {
      maxAzs: 2,
      natGateways: 0,
    });
    /**
     * Security Group
     */
    const ec2Sg = new SecurityGroup(this, 'ec2-sg', {
      vpc,
      allowAllOutbound: true,
    });
    ec2Sg.addIngressRule(
      Peer.anyIpv4(),
      Port.tcp(22),
      'allow SSH access from anywhere',
    );
    /**
     * EC2 Launch Template
     */
    //const path = require('path');
    let setupScript: string;
    let ami: IMachineImage;
    let ec2ImageBuilder: CfnInclude | undefined;
    const setupCommands = UserData.forLinux();

    if (props.enableEc2AutoUpdate) {
      const amiParameter = new StringParameter(this, 'ami', {
        parameterName: imageSsmParameterKey,
        stringValue: 'Invalid AMI',
        description: 'Store AMI built from EC2 Image Pipeline',
      });
      // This function will create EC2 Image Builder Pipeline and store AMI onto parameter store

      ec2ImageBuilder = CreateEc2ImageUpdater(
        this,
        amiParameter.parameterName,
        props.stackName,
        props.cpu,
        props.baseImage,
      );
      // Get the Value from AMI Parameter.
      ami = new GenericLinuxImage({ 'us-east-1': amiParameter.stringValue });

      setupScript = readFileSync(
        path.resolve(
          __dirname,
          `ec2-setup-scripts/${props.baseImage}/ec2-launch-with-custom-ami.sh`,
        ),
        'utf8',
      );
    } else {
      if (props.baseImage === 'ubuntu-20-lts') {
        // Use latest stable focal (20.04) Ubuntu AMI
        ami = MachineImage.fromSsmParameter(
          `/aws/service/canonical/ubuntu/server/focal/stable/current/${props.cpu}/hvm/ebs-gp2/ami-id`,
        );
      } else {
        const arch = props.cpu == 'arm64' ? 'arm64' : 'x86_64';
        // Use latest Amazon Linux2 with Kernel 5.10
        ami = MachineImage.fromSsmParameter(
          `/aws/service/ami-amazon-linux-latest/amzn2-ami-kernel-5.10-hvm-${arch}-gp2`,
        );
      }
      // Since we start with base image, we concatenate ami setup and launch script into one
      setupScript =
        readFileSync(
          path.resolve(
            __dirname,
            `ec2-setup-scripts/${props.baseImage}/ec2-ami-setup.sh`,
          ),
          'utf8',
        ) +
        readFileSync(
          path.resolve(
            __dirname,
            `ec2-setup-scripts/${props.baseImage}/ec2-launch-with-custom-ami.sh`,
          ),
          'utf8',
        );
    }
    // Here we introduce a new CFN parameter. Its value can be set by UpdateEcsLambda to update Stack with new AMI
    // In normal deployment, this parameter will have empty value

    const newAmi = new CfnParameter(this, 'newAmi', {
      type: 'String',
      description: 'new AMI built by EC2 Image Builder',
      default: '',
    });
    setupScript = setupScript
      .replace('${CPU}', props.cpu)
      .replace('${CLUSTER_STACK_NAME}', this.stackId)
      .replace('${ASG_LOGICAL_ID}', ec2AsgLogicalID)
      .replace('${AWS_REGION}', 'us-east-1')
      .replace(
        '{AMI}',
        newAmi.valueAsString.length > 0
          ? newAmi.valueAsString
          : ami.getImage(this).imageId,
      );

    setupCommands.addCommands(setupScript);

    const ec2launchTemplate = new LaunchTemplate(
      this,
      `fwe-simulator-${props.baseImage}-${props.cpu}`,
      {
        userData: setupCommands,
        instanceType: InstanceType.of(InstanceClass.M7G, InstanceSize.XLARGE),
        machineImage: ami,
        role: ec2Role,
        securityGroup: ec2Sg,
        keyName: props.ec2Key,
      },
    );
    if (ec2ImageBuilder) {
      // If enabling EC2 Auto Update feature, the Launch Template depends on EC2 Image Builder complete
      ec2launchTemplate.node.addDependency(ec2ImageBuilder);
    }
    /**
     * EC2 Auto Scaling Group
     */
    const asg = new CfnAutoScalingGroup(this, ec2AsgLogicalID, {
      maxSize: '100',
      minSize: props.ecsClusterMinimumInstances.toString(),
      desiredCapacity: props.ecsClusterMinimumInstances.toString(),
      healthCheckGracePeriod: 300,
      healthCheckType: 'EC2',
      mixedInstancesPolicy: {
        launchTemplate: {
          launchTemplateSpecification: {
            launchTemplateId: ec2launchTemplate.launchTemplateId,
            version: ec2launchTemplate.versionNumber,
          },
          overrides: [
            {
              instanceRequirements: {
                vCpuCount: {
                  min: 4,
                },
                memoryMiB: {
                  min: 1024 * 16,
                },
              },
            },
          ],
        },
      },
      availabilityZones: vpc.availabilityZones,
      vpcZoneIdentifier: vpc.publicSubnets.map((value) => value.subnetId),
      newInstancesProtectedFromScaleIn: true,
    });
    asg.cfnOptions.updatePolicy = {
      autoScalingReplacingUpdate: {
        willReplace: false,
      },
      autoScalingRollingUpdate: {
        maxBatchSize: 1,
        minInstancesInService: 2,
        minSuccessfulInstancesPercent: 100,
        pauseTime: 'PT10M',
        suspendProcesses: [
          'HealthCheck',
          'ReplaceUnhealthy',
          'AlarmNotification',
          'AZRebalance',
          'ScheduledActions',
        ],
        waitOnResourceSignals: true,
      },
    };
    asg.node.addDependency(vpc);

    // Per AWS Security requirement, any AWS-owned EC2 instance needs to setup central reporting to PVRE
    //if (props.baseImage === 'al2-kernel-5') {
    // This method only works for Amazon Linux 2
    //  installChronicleAgentOnAL2(
    //    this,
    //    process.env,
    //    ec2Role,
    //    asg.ref
    //  );
    //}

    /**
     * ECS Cluster
     */
    const capacityProvider = new CfnCapacityProvider(
      this,
      'ecs-cluster-capacity-provider',
      {
        autoScalingGroupProvider: {
          autoScalingGroupArn: asg.ref,
          managedScaling: {
            status: 'ENABLED',
            targetCapacity: 80,
          },
          managedTerminationProtection: 'ENABLED',
        },
        name: props.ecsCapacityProviderName,
      },
    );
    capacityProvider.node.addDependency(asg);

    const cluster = new CfnCluster(this, 'vehicle-simulator-ecs-cluster', {
      clusterName: props.ecsClusterName,
      capacityProviders: [capacityProvider.ref],
    });
    cluster.node.addDependency(capacityProvider);

    const LambdaExecutionRole = new Role(this, 'LambdaExecutionRole', {
      assumedBy: new ServicePrincipal('lambda.amazonaws.com'),
      inlinePolicies: {
        lambdaPolicy: new PolicyDocument({
          statements: [
            new PolicyStatement({
              actions: [
                'logs:CreateLogGroup',
                'logs:CreateLogStream',
                'logs:PutLogEvents',
                'cloudwatch:PutMetricData',
                'autoscaling:CompleteLifecycleAction',
                'autoscaling:DescribeScalingActivities',
                'autoscaling:RecordLifecycleActionHeartbeat',
                'ecs:UpdateContainerInstancesState',
                'ecs:Describe*',
                'ecs:List*',
                'ec2:DescribeInstanceAttribute',
              ],
              resources: ['*'],
            }),
          ],
        }),
      },
    });

    /**
     * Launch Lifecycle Lambda and Event Rule
     */
    const LifecycleLaunchLambda = new Function(
      this,
      'life-cycle-launch-lambda',
      {
        handler: 'index.lambda_handler',
        memorySize: 128,
        runtime: Runtime.PYTHON_3_9,
        role: LambdaExecutionRole,
        timeout: Duration.seconds(300),
        code: Code.fromAsset(path.resolve(__dirname, 'LifecycleLaunchLambda')),
      },
    );

    const LaunchLifeCycleHook = new CfnLifecycleHook(
      this,
      'launch-life-cycle-hook',
      {
        autoScalingGroupName: asg.ref,
        lifecycleTransition: 'autoscaling:EC2_INSTANCE_LAUNCHING',
      },
    );
    LaunchLifeCycleHook.node.addDependency(asg);

    const EventInvokeNewInstanceHealth = new Rule(
      this,
      'event-invoke-new-instance-health',
      {
        description:
          'Invokes a Lambda Function to check a newly launched instances health during autoscaling',
        eventPattern: {
          detail: {
            AutoScalingGroupName: [asg.ref],
          },
          detailType: ['EC2 Instance-launch Lifecycle Action'],
          source: ['aws.autoscaling'],
        },
        targets: [new LambdaFunction(LifecycleLaunchLambda)],
      },
    );
    EventInvokeNewInstanceHealth.node.addDependency(asg);

    const EventContinueNewInstanceHealth = new Rule(
      this,
      'event-continue-new-instance-health',
      {
        description:
          'Invokes a Lambda Function to check a newly launched instances health when our initial Lambda function has timed out ',
        eventPattern: {
          detail: {
            eventName: ['RecordLifecycleActionHeartbeat'],
            eventSource: ['autoscaling.amazonaws.com'],
            requestParameters: {
              autoScalingGroupName: [asg.ref],
              lifecycleHookName: [LaunchLifeCycleHook.ref],
            },
          },
          detailType: ['AWS API Call via CloudTrail'],
          source: ['aws.autoscaling'],
        },
        targets: [new LambdaFunction(LifecycleLaunchLambda)],
      },
    );
    EventContinueNewInstanceHealth.node.addDependency(asg);
    EventContinueNewInstanceHealth.node.addDependency(LaunchLifeCycleHook);

    /**
     * Termination Lifecycle Lambda and Event Rule
     */
    const LifecycleTerminateLambda = new Function(
      this,
      'life-cycle-terminate-lambda',
      {
        handler: 'index.lambda_handler',
        memorySize: 128,
        runtime: Runtime.PYTHON_3_9,
        role: LambdaExecutionRole,
        timeout: Duration.seconds(300),
        code: Code.fromAsset(
          path.resolve(__dirname, 'LifecycleTerminateLambda'),
        ),
      },
    );

    const TerminationLifeCycleHook = new CfnLifecycleHook(
      this,
      'termination-life-cycle-hook',
      {
        autoScalingGroupName: asg.ref,
        lifecycleTransition: 'autoscaling:EC2_INSTANCE_TERMINATING',
      },
    );
    TerminationLifeCycleHook.node.addDependency(asg);

    const EventInvokeClusterDrain = new Rule(
      this,
      'event-invoke-cluster-drain',
      {
        description:
          'Invokes a Lambda Function to handle draining the ECS cluster instance upon termination',
        eventPattern: {
          detail: {
            AutoScalingGroupName: [asg.ref],
          },
          detailType: ['EC2 Instance-terminate Lifecycle Action'],
          source: ['aws.autoscaling'],
        },
        targets: [new LambdaFunction(LifecycleTerminateLambda)],
      },
    );
    EventInvokeClusterDrain.node.addDependency(asg);

    const EventContinueClusterDrain = new Rule(
      this,
      'event-continue-cluster-Drain',
      {
        description:
          'Invokes a Lambda Function to continue draining the ECS cluster when our initial Lambda function has timed out  ',
        eventPattern: {
          detail: {
            eventName: ['RecordLifecycleActionHeartbeat'],
            eventSource: ['autoscaling.amazonaws.com'],
            requestParameters: {
              autoScalingGroupName: [asg.ref],
              lifecycleHookName: [TerminationLifeCycleHook.ref],
            },
          },
          detailType: ['AWS API Call via CloudTrail'],
          source: ['aws.autoscaling'],
        },
        targets: [new LambdaFunction(LifecycleTerminateLambda)],
      },
    );
    EventContinueClusterDrain.node.addDependency(asg);
    EventContinueClusterDrain.node.addDependency(TerminationLifeCycleHook);
  }
}
